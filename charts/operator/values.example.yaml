## This is testing configuration file
## Needed to test operator helm chart on test network
##

## Validators configuration
##
verticalAutoscaler:
  enabled: true
validatorsCount: 1
type: prysm
graffiti: "StakeWise"
publicKey: ""
networkID: "prater"
metrics:
  enabled: true
  serviceMonitor:
    enabled: true
persistence:
  enabled: true
  storageClassName: "ssd-storage"
  accessModes:
    - ReadWriteOnce
  size: 10Gi

## Geth node configuration
##
geth:
  enabled: true
  replicas: 1
  extraFlags:
    - "--syncmode=snap"
    - "--goerli"
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

## Erigon node configuration
##
## Erigon can be used as an execution-layer for beacon chain consensus clients (Eth2).
## Default configuration is ok.
## Once the JSON-RPC daemon is running, all you need to do is point your
## beacon chain client to erigon:8545, where is either localhost
## or the IP address of the device running the JSON-RPC daemon.
## Erigon has been tested with Lighthouse however all other clients that
## support JSON-RPC should also work.
erigon:
  enabled: false
  replicas: 1
  chain: goerli
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

## Prysm beacon chain node configuration
##
prysm:
  enabled: true
  replicas: 1
  networkID: prater
  eth1Endpoint: "http://geth:8545"
  extraFlags:
    # Beacon chain options
    - "--accept-terms-of-use"
    # p2p options
    - "--p2p-max-peers=100"
    - "--enable-peer-scorer"
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
  persistence:
    enabled: true
    storageClassName: "ssd-storage"
    accessModes:
      - ReadWriteOnce
    size: 100Gi

## Lighthouse beacon chain node configuration
##
lighthouse:
  enabled: false
  replicas: 1
  networkID: prater
  eth1Endpoints:
    - http://geth:8545
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true
  persistence:
    enabled: true
    storageClassName: "ssd-storage"
    accessModes:
      - ReadWriteOnce
    size: 100Gi


## Hashicorp Vault configurations
##
vault:
  enabled: true
  server:
    enabled: true
    dataStorage:
      enabled: true
      storageClass: "ssd-storage"
      accessMode: ReadWriteOnce
      size: 10Gi
    ha:
      enabled: true
      replicas: 3
      raft:
        enabled: true
        # Note: Configuration files are stored in ConfigMaps so sensitive data
        # such as passwords should be either mounted through extraSecretEnvironmentVars
        # or through a Kube secret.  For more information see:
        # https://www.vaultproject.io/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations
        config: |
          ui = true
          listener "tcp" {
            tls_disable = 1
            address = "[::]:8200"
            cluster_address = "[::]:8201"
          }
          storage "raft" {
            path = "/vault/data"
          }
          service_registration "kubernetes" {}
          seal "gcpckms" {
             project     = "project-id"
             region      = "global"
             key_ring    = "operator"
             crypto_key  = "vault"
          }
    extraEnvironmentVars:
      GOOGLE_REGION: global
      GOOGLE_PROJECT: project-id
      GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/project-id/gcp-creds.json

    # volumes is a list of volumes made available to all containers. These are rendered
    # via toYaml rather than pre-processed like the extraVolumes value.
    # The purpose is to make it easy to share volumes between containers.
    volumes:
      - name: gcp-creds
        secret:
          secretName: gcp-creds
          items:
            - key: gcp-creds.json
              path: gcp-creds.json

    # volumeMounts is a list of volumeMounts for the main server container. These are rendered
    # via toYaml rather than pre-processed like the extraVolumes value.
    # The purpose is to make it easy to share volumes between containers.
    volumeMounts:
      - name: gcp-creds
        mountPath: "/vault/userconfig/project-id/gcp-creds.json"
        subPath: gcp-creds.json
        readOnly: true
   
  ui:
    enabled: true
