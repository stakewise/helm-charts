# Default values for erigon.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

## Init image is used to chown data volume, initialise genesis, etc.
##
initImage:
  repository: "busybox"
  tag: "1.34"
  pullPolicy: IfNotPresent

image:
  repository: thorax/erigon
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "v2021.11.03"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext:
  fsGroup: 1001
  runAsUser: 1001

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000


## Erigon configuration
##

# Name of the net to join
network: mainnet

erigon:
  # Data directory for the databases
  dataDir: "/data/erigon"
  # Directory to store the ethash mining DAGs
  ethHashDagDir: "/data/erigon-ethhash"
  # Batch size for the execution stage
  batchSize: "512M"
  # Outstanding limit of block bodies being downloaded
  blockDownloaderWindow: "32768"
  # Enabling internal db logs. Very high verbosity levels may require recompile db
  databaseVerbosity: "2"
  # private api network address, for example: 127.0.0.1:9090,
  # empty string means not to start the listener.
  # Do not expose to public network.
  # Serves remote database interface (default: "127.0.0.1:9090")
  privateApiAddr: 127.0.0.1:9090
  # HTTP-RPC server listening interface
  httpAddr: 0.0.0.0
  # Comma separated list of virtual hostnames from which to accept requests (server enforced).
  # Accepts '*' wildcard
  httpVhosts: "*"
  # Comma separated list of domains from which to accept cross origin requests (browser enforced)
  httpCorsDomain: "*"
  # API's offered over the HTTP-RPC interface: eth,erigon,web3,net,debug,trace,txpool,db.
  # Supported methods: https://github.com/ledgerwatch/erigon/tree/devel/cmd/rpcdaemon
  httpApi: "eth,erigon,web3,net,txpool"
  # Amount of requests server handle simultaneously - requests
  # over this limit will wait.
  # Increase it - if clients see 'request timeout' while server
  # load is low - it means your 'hot data' is small or have much RAM.
  privateApiRateLimit: "31872"
  # Buffer size for ETL operations.
  etlBufferSize: "256MB"
  # Network listening port
  port: "30303"
  # ETH65 Network listening port
  p2pEth65Port: "30304"
  # NAT port mapping mechanism (any|none|upnp|pmp|extip:<IP>)
  #     "" or "none"         default - do not nat
  #     "extip:77.12.33.4"   will assume the local machine is reachable on the given IP
  #     "any"                uses the first auto-detected mechanism
  #     "upnp"               uses the Universal Plug and Play protocol
  #     "pmp"                uses NAT-PMP with an auto-detected gateway address
  #     "pmp:192.168.0.1"    uses NAT-PMP with the given gateway address
  nat: ""
  # P2P node key file
  nodeKey: ""
  # P2P node key as hex (for testing)
  nodeKeyHex: ""
  # Comma separated enode URLs to connect to
  staticPeers: ""
  # Comma separated enode URLs which are always allowed to connect, even above the peer limit
  trustedPeers: ""
  # Maximum number of network peers (network disabled if set to 0)
  maxPeers: "100"

  # Enable mining
  mine: false
  # Comma separated HTTP URL list to notify of new work packages
  minerNotify: ""
  # Target gas floor for mined blocks
  minerGasTarget: "8000000"
  # Target gas ceiling for mined blocks
  minerGasLimit: "8000000"
  # Public address for block mining rewards
  minerEtherBase: "0"
  # Block extra data set by the miner
  minerExtraData: ""
  # Disable remote sealing verification
  minerNoVerify: false

  ## Extra flags for mainnet node
  ##
  mainnetExtraFlags:
    - "--prune.r.before=11184524"
    - "--prune=htc"

  ## Extra flags for goerli node
  ##
  goerliExtraFlags:
  - "--prune.r.before=4367322"
  - "--prune=htc"

service:
  type: ClusterIP
  port:
    rpc: 8545
    grpc: 9090

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

## Configure liveness and readiness probes
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
## NB! readinessProbe and livenessProbe must be disabled before fully synced
##
readinessProbe:
  initialDelaySeconds: 180
  timeoutSeconds: 1
  periodSeconds: 60
  failureThreshold: 3
  successThreshold: 1
  httpGet:
    path: /health
    port: 8545
    scheme: HTTP
livenessProbe:
  initialDelaySeconds: 60
  timeoutSeconds: 1
  periodSeconds: 60
  failureThreshold: 60
  successThreshold: 1
  httpGet:
    path: /health
    port: 8545
    scheme: HTTP

## Node labels for pod assignment
## ref: https://kubernetes.io/docs/user-guide/node-selection/
##
nodeSelector: {}

## Tolerations for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
##
tolerations: []

## Affinity for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
##
affinity: {}

## Used to assign priority to pods
## ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
##
priorityClassName: ""

## If false, data ownership will not be reset at startup
## This allows the geth node to be run with an arbitrary user
##
initChownData: true

## Whether or not to allocate persistent volume disk for the data directory.
## In case of node failure, the node data directory will still persist.
##
persistence:
  enabled: true
  storageClassName: ""
  accessModes:
    - ReadWriteOnce
  size: 800Gi

## Monitoring
##
metrics:
  ## Whether to enable metrics collection or not
  ##
  enabled: false

  # Enable stand-alone metrics HTTP server listening interface
  addr: "0.0.0.0"
  # Metrics HTTP server listening port
  port: "6060"

  ## Prometheus Service Monitor
  ## ref: https://github.com/coreos/prometheus-operator
  ##      https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
  ##
  serviceMonitor:
    ## @param metrics.serviceMonitor.enabled Create ServiceMonitor resource(s) for scraping metrics using PrometheusOperator
    ##
    enabled: false
    ## @param metrics.serviceMonitor.namespace The namespace in which the ServiceMonitor will be created
    ##
    namespace: ""
    ## @param metrics.serviceMonitor.interval The interval at which metrics should be scraped
    ##
    interval: 30s
    ## @param metrics.serviceMonitor.scrapeTimeout The timeout after which the scrape is ended
    ##
    scrapeTimeout: ""
    ## @param metrics.serviceMonitor.relabellings Metrics RelabelConfigs to apply to samples before scraping.
    ##
    relabellings: []
    ## @param metrics.serviceMonitor.metricRelabelings Metrics RelabelConfigs to apply to samples before ingestion.
    ##
    metricRelabelings: []
    ## @param metrics.serviceMonitor.honorLabels Specify honorLabels parameter to add the scrape endpoint
    ##
    honorLabels: false
    ## @param metrics.serviceMonitor.additionalLabels Additional labels that can be used so ServiceMonitor resource(s) can be discovered by Prometheus
    ##
    additionalLabels: {}
  ## Custom PrometheusRule to be defined
  ## ref: https://github.com/coreos/prometheus-operator#customresourcedefinitions
  ##
  prometheusRule:
    ## @param metrics.prometheusRule.enabled Create a custom prometheusRule Resource for scraping metrics using PrometheusOperator
    ##
    enabled: false
    ## @param metrics.prometheusRule.namespace The namespace in which the prometheusRule will be created
    ##
    namespace: ""
    ## @param metrics.prometheusRule.additionalLabels Additional labels for the prometheusRule
    ##
    additionalLabels: {}
    ## @param metrics.prometheusRule.rules Custom Prometheus rules
    ## e.g:
    ## rules:
    ##   - alert: PrysmBeaconNodeDown
    ##     expr: up{job='{{ include "prysm.fullname" . }}-prysm-beacon'} == 0
    ##     for: 1m
    ##     labels:
    ##       severity: critical
    ##     annotations:
    ##       summary: Prysm beacon node is down
    ##       description: Check {{ printf "{{ $labels.pod }}" }} beacon node in namespace {{ printf "{{ $labels.namespace }}" }}
    ##   - alert: Prysm50SlotsBehind
    ##     expr: beacon_clock_time_slot-beacon_head_slot > 50
    ##     for: 2m
    ##     labels:
    ##       severity: critical
    ##     annotations:
    ##       summary: Prysm beacon node is out of sync
    ##       description: Check {{ printf  "{{ $labels.pod }}" }} beacon node in namespace {{ printf "{{ $labels.namespace }}" }}
    ##   - alert: PrysmParticipationRateLessThen66Percent
    ##     expr: beacon_prev_epoch_target_gwei/beacon_prev_epoch_active_gwei*100 < 66
    ##     for: 5m
    ##     labels:
    ##       severity: critical
    ##     annotations:
    ##       summary: Prysm beacon node participation rate less then 66%
    ##       description: Check {{ printf "{{ $labels.pod }}" }} beacon node in namespace {{ printf "{{ $labels.namespace }}" }}
    ##   - alert: PrysmBeaconNodeRestarted
    ##     expr: (time()-process_start_time_seconds{job='{{ include "prysm.fullname" . }}-prysm-beacon'})/3600 < 0.1
    ##     for: 1m
    ##     labels:
    ##       severity: warning
    ##     annotations:
    ##       summary: Prysm beacon node was restarted
    ##       description: Check {{ printf "{{ $labels.pod }}" }} beacon node in namespace {{ printf "{{ $labels.namespace }}" }}
    ##
    rules: []
