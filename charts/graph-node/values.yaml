# Default values for graph-node.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: graphprotocol/graph-node
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "v0.24.2"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

## Graph Node Configuration
#
graph:
  # how often to poll Ethereum for new blocks (in ms)
  ethereumPollingInterval: 500
  # The ideal amount of triggers to be processed in a batch.
  # If this is too small it may cause too many requests to the ethereum node,
  # if it is too large it may cause unreasonably expensive calls to
  # the ethereum node and excessive memory usage
  graphEthereumTargetTriggersPerBlockRange: 100
  # graph-node queries traces for a given block range when a subgraph
  # defines call handlers or block handlers with a call filter.
  # The value of this variable controls the number of blocks
  # to scan in a single RPC request for traces from the Ethereum node.
  ethereumTraceStreamStepSize: 50
  # Set to true to disable block ingestion.
  # Leave unset or set to false to leave block ingestion enabled.
  disableBlockIngestor: true
  # Number of Ethereum blocks to request in parallel.
  # Also limits other parallel requests such such as trace_filter.
  ethereumBlockBatchSize: 10
  # Maximum number of blocks to scan for triggers in each request
  graphEthereumMaxBlockRangeSize: 1000
  # Maximum range size for eth.getLogs requests that dont
  # filter on contract address, only event signature.
  graphEthereumMaxEventOnlyRange: 500
  # Timeout for Ethereum JSON-RPC requests
  graphEthereumJsonRpcTimeout: 180
  # Number of times to retry JSON-RPC requests made against Ethereum.
  # This is used for requests that will not fail the subgraph if the limit
  # is reached, but will simply restart the syncing step, so it can be low.
  # This limit guards against scenarios such as requesting a block hash that
  # has been reorged.
  graphEthereumRequestRetries: 10
  # The maximum number of concurrent requests made against Ethereum
  # for requesting transaction receipts during block ingestion.
  graphEthereumBlockIngestorMaxConcurrentJsonRpcCallsForTxnReceipts: 1000
  # Set to true to clean up unneeded blocks from the cache in the database.
  # When this is false or unset (the default), blocks will never be removed
  # from the block cache. This setting should only be used during development
  # to reduce the size of the database. In production environments,
  # it will cause multiple downloads of the same blocks and therefore slow
  # the system down. This setting can not be used if the store uses more
  # than one shard.
  graphEthereumCleanupBlocks: "false"
  # Amount of time a mapping handler is allowed to take (in seconds)
  graphMappingHandlerTimeout: 0
  # Timeout for IPFS, which includes requests for manifest files and
  # from mappings using ipfs.cat or ipfs.map (in seconds)
  graphIpfsTimeout: 30
  # Maximum size for a file that can be retrieved with ipfs.cat (in bytes)
  graphMaxIpfsFileBytes: ""
  # maximum size of files that can be processed with ipfs.map.
  # When a file is processed through ipfs.map, the entities generated
  # from that are kept in memory until the entire file is done processing.
  # This setting therefore limits how much memory a call to
  # ipfs.map may use. (in bytes)
  graphMaxIpfsMapFileSize: 268435456
  # Maximum number of files cached in the the ipfs.cat cache
  graphMaxIpfsCacheSize: 50
  # Maximum size of files that are cached in the ipfs.cat cache
  graphMaxIpfsCacheFileSize: 1048576
  # Size of the entity cache, in kilobytes
  graphEntityCacheSize: 10000
  # How many recent blocks per network should be kept in the query cache.
  # This should be kept small since the lookup time and the cache memory
  # usage are proportional to this value. Set to 0 to disable the cache.
  graphQueryCacheBlocks: 1
  # Maximum total memory to be used by the query cache, in MB.
  # The total amount of memory used for caching will be twice this
  # value - once for recent blocks, divided evenly among the
  # GRAPH_QUERY_CACHE_BLOCKS, and once for frequent queries against older blocks.
  # The default is plenty for most loads, particularly if
  # GRAPH_QUERY_CACHE_BLOCKS is kept small.
  # Defaults to 1000, which corresponds to 1GB.
  graphQueryCacheMaxMem: 1000
  # Number of queries after which a cache entry can be considered stale.
  graphQueryCacheStalePeriod: 100
  # Maximum apiVersion supported, if a developer tries to create a subgraph
  # with a higher apiVersion than this in their mappings, they'll receive an error.
  graphMaxApiVersion: 0.0.6
  # Maximum stack size for the WASM runtime,
  # if exceeded the execution stops and an error is thrown
  graphRuntimeMaxStackSize: ""
  # Maximum execution time for a graphql query, in seconds
  graphGraphqlQueryTimeout: 0
  # While a subgraph is syncing, subscriptions to that subgraph get
  # updated at most this often, in ms.
  subscriptionThrottleInterval: 1000
  # Maximum complexity for a graphql query. Default is unlimited.
  # Typical introspection queries have a complexity of just over 1 million,
  # so setting a value below that may interfere with introspection done
  # by graphql clients.
  graphGraphqlMaxComplexity: 0
  # Maximum depth of a graphql query. Default (and maximum) is 255.
  graphGraphqlMaxDepth: 255
  # Maximum value that can be used for the first argument in GraphQL queries.
  # If not provided, first defaults to 100.
  # The default value for GRAPH_GRAPHQL_MAX_FIRST is 1000.
  graphGraphqlMaxFirst: 1000
  # Maximum value that can be used for the skip argument in GraphQL queries. 
  graphGraphqlMaxSkip: ""
  # If a GraphQL result is larger than these sizes in bytes,
  # log a warning respectively abort query execution and return an error.
  # The size of the result is checked while the response is being constructed,
  # so that execution does not take more memory than what is configured.
  # The default value for both is unlimited.
  graphGraphqlWarnResultSize: ""
  graphGraphqlErrorResultSize: ""
  # Maximum number of GraphQL operations per WebSocket connection.
  # Any operation created after the limit will return an error to the client.
  # Default: unlimited.
  graphGraphqlMaxOperationsPerConnection: ""
  # The maximum number of seconds an individual SQL query is allowed to take
  # during GraphQL execution.
  # Default: unlimited
  graphSqlStatementTimeout: ""
  # Disables the internal mechanism that is used to trigger updates on GraphQL
  # subscriptions. When this variable is set to any value, graph-node
  # will still accept GraphQL subscriptions, but they won't receive any updates.
  graphDisableSubscriptionNotifications: ""
  # Sets the node ID, allowing to run multiple Graph Nodes in parallel and
  # deploy to specific nodes; each ID must be unique among the set of nodes.
  graphNodeId: ""
  # Control log levels
  # values: debug, error, info, warn, or trace
  graphLog: "info"
  # Postgres instance used when running tests.
  # Set to postgresql://<DBUSER>:<DBPASSWORD>@<DBHOST>:<DBPORT>/<DBNAME>
  thegraphStorePostgresDieselUrl: ""
  #  If set, the process will be killed if unresponsive.
  graphKillIfUnresponsive: ""
  # Control whether the process logs details of processing GraphQL and SQL queries.
  # The value is a comma separated list of sql,gql, and cache.
  # If gql is present in the list, each GraphQL query made against the node is
  # logged at level info. The log message contains the subgraph that was queried,
  # the query, its variables, the amount of time the query took, and a unique query_id.
  # If sql is present, the SQL queries that a GraphQL query causes are logged.
  # The log message contains the subgraph, the query, its bind variables,
  # the amount of time it took to execute the query, the number of entities found
  # by the query, and the query_id of the GraphQL query that caused the SQL query.
  # These SQL queries are marked with component: GraphQlRunner
  # There are additional SQL queries that get logged when sql is given.
  # These are queries caused by mappings when processing blocks for a subgraph,
  # and queries caused by subscriptions. If cache is present in addition to gql,
  # also logs information for each toplevel GraphQL query field whether that could
  # be retrieved from cache or not. Defaults to no logging.
  graphLogQueryTiming: ""
  # How many simultaneous connections to allow to the store.
  # Due to implementation details, this value may not be strictly adhered to.
  storeConnectionPoolSize: 10
  # Logs Proof of Indexing events deterministically.
  # This may be useful for debugging.
  graphLogPoiEvents: ""
  # Load can be automatically throttled if load measurements over a time period
  # of GRAPH_LOAD_WINDOW_SIZE seconds exceed a threshold.
  # Measurements within each window are binned into bins of GRAPH_LOAD_BIN_SIZE seconds.
  # The variables default to 300s and 1s
  graphLoadWindowSize: 300
  graphLoadBinSize: 1
  # If wait times for getting database connections go above this threshold,
  # throttle queries until the wait times fall below the threshold.
  # Value is in milliseconds, and defaults to 0 which turns throttling and
  # any associated statistics collection off.
  graphLoadThreshold: 0
  # When the system is overloaded, any query that causes more than this fraction of
  # the effort will be rejected for as long as the process is running
  # (i.e., even after the overload situation is resolved) If this variable is not set,
  # no queries will ever be jailed, but they will still be subject to normal
  # load management when the system is overloaded.
  graphLoadJailThreshold: ""
  # Perform all the steps that the load manager would given the other
  # load management configuration settings, but never actually decline to run a query,
  # instead log about load management decisions. Set to true to turn simulation on,
  # defaults to false
  graphLoadSimulate: "false"
  # How long to wait to connect to a database before assuming the database
  # is down in ms. Defaults to 5000ms.
  graphStoreConnectionTimeout: 5000
  # Default is instant, set to synced to only switch a named subgraph to a
  # new deployment once it has synced, making the new deployment the "Pending" version.
  experimentalSubgraphVersionSwitchingMode: instant
  # How long to wait before removing an unused deployment.
  # The system periodically checks and marks deployments that are not used by
  # any subgraphs any longer. Once a deployment has been identified as unused,
  # graph-node will wait at least this long before actually deleting the data
  # (value is in minutes, defaults to 360, i.e. 6 hours)
  graphRemoveUnusedInterval: 360
  # IPFS URL
  ipfsUrl: graph-node-ipfs:5001
  # Ethereum Node Address
  ethereumNode: mainnet:http://erigon.chain:8545

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

service:
  type: ClusterIP
  ports:
    # Port for the GraphQL HTTP server
    http: 8000
    # Port for the GraphQL WebSocket server
    websocket: 8001
    # Port for the JSON-RPC admin server
    jsonrpc: 8020
    # Port for index status
    indexStatus: 8030
    # Port for Prometheus Exporter
    metrics: 8040

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

## Configure resource requests and limits.
## http://kubernetes.io/docs/user-guide/compute-resources/
##
resources: { }

## Node labels for pod assignment
## ref: https://kubernetes.io/docs/user-guide/node-selection/
##
nodeSelector: {}

## Tolerations for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
##
tolerations: []

## Affinity for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
##
affinity: {}

## used to assign priority to pods
## ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
##
priorityClassName: ""

## PostgreSQL Server
#
postgresql:
  enabled: true
  volumePermissions:
    enabled: true
    image:
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 10-debian-10-r98
      pullPolicy: Always
    securityContext:
      runAsUser: 0
  securityContext:
    enabled: true
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  rbac:
    create: false
  postgresqlHost: graph-node-postgresql
  postgresqlPort: "5432"
  postgresqlUsername: "postgres"
  postgresqlPassword: "graph"
  usePasswordFile: true
  postgresqlDatabase: graph
  postgresqlDataDir: /bitnami/postgresql/data
  primaryAsStandBy:
    enabled: false
  postgresqlSharedPreloadLibraries: "pgaudit,pg_stat_statements"
  shmVolume:
    enabled: true
    chmod:
      enabled: true
  persistence:
    enabled: true
    mountPath: /bitnami/postgresql
    subPath: ''
    accessModes:
      - ReadWriteOnce
    size: 20Gi
    annotations: { }
    selector: { }
  readReplicas:
    persistence:
      enabled: true
  resources:
    requests:
      memory: 384Mi
      cpu: 250m
  networkPolicy:
    enabled: false
  tls:
    enabled: false
  metrics:
    enabled: true

# IPFS Server
ipfs:
  enabled: true
